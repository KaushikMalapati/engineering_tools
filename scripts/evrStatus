#!/bin/bash

# New usage string
usage() {
cat << EOF
usage: $0 <hutch>|<PV>...[-evr] [-h] [-l] [--pvs [<hutch>...]] [ --show [ <keyword>...]]

Displays a status GUI for the EVRs of the selected hutch or EVR PVs. GUI includes links to event code expert screens. The List of EVRs is not exhaustive, but rather displays one EVR per host.

OPTION: 
    -evr                     Prompt user to enter in EVR PVs manually line by line.
    -h                       Display this help text.
    -l                       List available hutches to display EVR status.
    --pvs [<hutch>...]       Display the EVR PVs for a requested hutch that are built into this script.
    --show [<keyword>...]    Display EVRs matching user specified keyword search term(s).
EOF
}


# evrList
evrs=(
EVR:FEE1:441
EVR:FEE:GASDET:DAQ
IM1L1:PPM:CAM:EVR
EVR:LAS:FTL:01
EVR:LAS:LHN:01
EVR:LAS:LHN:04
EVR:LAS:LLN:01
XPP:IPM:EVR
XPP:R30:EVR:26
XPP:R30:EVR:28
XPP:R32:EVR:32
XPP:SB2:BMMON:EVR
XPP:USR:EVR
HFX:DG2:BMMON:EVR
HFX:EVR:DG2:CVV:01
HFX:EVR:MON:CVV:01
XRT:EVR:MISC02
XRT:EVR:R48
XRT:R04:EVR:33
XRT:R05:EVR:41
EVR:DET:01
XCS:R42:EVR:01
XCS:R44:EVR:01
XCS:SB2:BMMON:EVR
XCS:SND:DIO:EVR
XCS:USR:EVR
EVR:XCS:USDUSB4:01
EVR:LAS:XCS:01
MFX:DG1:BMMON:EVR
MFX:EVR:DG2:P6740
MFX:EVR:DIA:P6740
MFX:LAS:EVR:01
MFX:REC:EVR:02
EVR:LAS:MFX:01
CXI:DG2:BMMON:EVR
CXI:IPM:EVR
CXI:R48:EVR:41
CXI:REC:EVR:01
CXI:REC:EVR:04
EVR:LAS:CXI:01
MEC:BEAM:EVR:01
MEC:LAS:EVR:01
MEC:TC1:EVR:01
MEC:XT2-1:BMMON:EVR
EVR:MEC:REC01
EVR:MEC:USR01
LAS:MEC:EVR:01
LAS:MEC:EVR:03
)

# Areas to search
areas=(
"MEC"
"MFX"
"CXI"
"XCS"
"XRT"
"XPP"
"TMO"
"FEE"
"LAS"
"DET"
"RIX"
"TXI"
"ALL"
)

# Reads user input when there are no command line arguments
read_hutch () {   
    echo "Enter area you'd like to see ie (XPP, TMO, FEE, ALL..etc):" 
    echo "(Press enter to exit this session)"
    read -r  hutch
    hutch=${hutch^^}  # make user input uppercase for user friendliness  

    if [[ "${hutch}" == "" ]]; then 
        exit
    fi
}

# Checks if user inputted area is valid 

in_areas() {
    hutch_in_areas=$(echo "${areas[@]}" | grep -o "$hutch" | wc -w) # 1 or 0 depending if user input returns a match or not

    if ! [ "$hutch_in_areas" -eq 1 ];then 
        echo "The area you searched:" "$hutch" " does not correspond to any currently in the NEH or FEH where EVRs are located... the list of available areas is:"
        printf "\n"
        printf '%s\n' "${areas[@]}"
        printf "\n"
        echo "Try again: evrStatus <area1> <area2> <area3> ..."
        echo "To see the full list of command line inputs: evrStatus -h"
       exit
    fi
}

# Creates array of requested evr PVs to see the status of

req_evrs_func() {
    req_evrs=()
    if [[ "$hutch" == "ALL" ]]; then  # all callable pvs are requested evr pvs 
        for i in "${evrs[@]}"; do
            req_evrs+=("$i")
        done
    else
        for i in "${evrs[@]}"; do # call only pvs that are associated with specified hutch
            if [[ $i == *"$hutch"* ]]; then
	        req_evrs+=("$i")
	    fi
        done
    fi
    # These PVs need to be added manually b/c their names do not have a "$hutch" identifier in them
    if [[ "$hutch" == "XRT" ]]; then
	req_evrs+=("HFX:DG2:BMMON:EVR")
	req_evrs+=("HFX:EVR:DG2:CVV:01")
	req_evrs+=("HFX:EVR:MON:CVV:01")
    elif [[ "$hutch" == "FEE" ]]; then
	req_evrs+=("IM1L1:PPM:CAM:EVR")
    fi
    export req_evrs
}

# Transforms array of requested PVs into an array of strings which is readable by the Extensible Display Manager
to_display () {
    source /cds/group/pcds/pyps/conda/pcds_conda
    echo "Displaying EVR status screen for " "$hutch" "..."    
    printf "\n"           
    pydm /reg/g/pcds/epics-dev/screens/pydm/scripts/evr.py -p "${req_evrs[@]}" "${pv_args[@]}"
}

# Begin Command line argument handling:

command_args_string="$*"


# Types of command line arguments:

pv_args=()
opt_args=()
opts_available=("-L" "--PVS" "-H" "--H" "--HELP" "-Help" "Help" "-EVR" "--SHOW")
area_args=()
except_args=()

# Command line args classification logic:

for i in $command_args_string; do
    i=${i^^}
    if [[ "$i" =~ ":" && ${#i} -gt 10 ]]; then
        pv_args+=("$i")
    elif [[ "${areas[*]}" =~ $i ]]; then   # Initial classification filtering
        for j in "${areas[@]}"; do           
            if [[ "$j" == "$i" ]]; then      # Exact Match Filtering
                area_args+=("$i")
            fi
        done
    elif [[ "${opts_available[*]}" =~ $i ]]; then  # Initial classification filtering
	for j in "${opts_available[@]}"; do            
	    if [[ "$j" == "$i" ]];then                 # Exact Match Filtering
                opt_args+=("$i")
            fi
        done
    elif [[ "${#i}" -eq  1 ]]; then 
        except_args+=("$i")
    else
        except_args+=("$i")
    fi
done


# Argument Handling Functions:

# allow the user to manually enter EVR PVs to see the status when propmpted

manual_pv_entry() { 
    echo "Enter the EVR PV(s) you would like to see the display status of. Please only enter one per line:" 
    echo "(Press Return to exit this dialog)"
    read -r input
    if [[ "$input" == "" ]]; then
        exit
    else
        pv_args+=("$input")
    fi
    while read -r line; do
        if [[ "$line" == "" ]]; then
            break
        else
            pv_args+=("$line")
        fi
    done 
                                                                                
    to_display
}

except_handling() {
    for i in "${except_args[@]}"; do

# 1: Wrong type of PV format  
        if [[ "$i" =~ ":" && ${#i} -lt 10 ]]; then
            echo "There seems to be a typo in your requested PV: " "$i" 
            echo "Please try again"

# 2: Wrong type of area format --> error handling is already executed in the in_areas function

# 3: Option non-existant
        elif ! [[ "${opts_available[*]}" =~ $i ]]; then
            echo "Invalid Argument: " "$i"
            printf "\n"
	    printf "The list of supported command line arguments are: \n -l \n -evr \n <hutch> \n <PV> \n --pvs [<hutch>...] \n --show [<keyword>...] \n"
            printf "\n"
	    echo "For full documentation: $ evrStatus -h "
	elif [[ "${#i}" -eq 1 ]]; then
            echo "Invalid Argument: " "$i"
	    printf "\n"
            printf "The list of supported command line arguments are: \n -l \n -evr \n <hutch> \n <PV> \n --pvs [<hutch>...] \n --show [<keyword>...] \n"
	    printf "\n"
            echo "For full documentation: $ evrStatus -h "
	elif [[ "${command_args_string[*]}" -eq 1 ]]; then
	    echo "Invalid Argument: " "$i"
	    printf "\n"
            printf "The list of supported command line arguments are: \n -l \n -evr \n <hutch> \n <PV> \n --pvs [<hutch>...] \n --show [<keyword>...] \n"
	    printf "\n"
            echo "For full documentation: $ evrStatus -h "
        fi
    done
}

# allow the user to display EVRs containing keywords via a command line search

keyword_search(){

count=0
command_args_string="${command_args_string^^}"

IFS=" " 
read -ra command_args <<< "$command_args_string"

for i in "${command_args[@]}"; do
    if  [[ $i != "--SHOW" ]]; then
        keywords+=("$i")
    fi

done 

    for keyword in "${keywords[@]}"; do
 
        keyword_in_evrs=$(echo "${evrs[@]}" | grep -o "$keyword" | wc -w) # 1 or 0 depending if user input returns a match or not
        
	if [[ $keyword_in_evrs -eq 0 ]]; then
            echo "Sorry your search:" "$keyword"
            echo "Did not yield any results"
	    printf "\n"
	  
 	else
	    matches+=("$keyword")
	    count=$((count + 1))   
            for evr in "${evrs[@]}"; do
                if [[ $evr =~ $keyword ]]; then
                req_evrs+=("$evr")
                fi    
	    done
	fi
    done
export req_evrs count matches
}


# Status Screen Display Handling Logic:

if [[ "$1" == "" ]]; then

    read_hutch #execute user input function first
    in_areas # test if user input is in accepted list
    req_evrs_func 
    to_display
fi
if [[ "${opt_args[*]}" == *"--SHOW"* ]]; then
    
    keyword_search
    if [[ $count -gt 0 ]]; then
        to_display
        echo "Terms containing: " "${matches[@]}" 
        exit
    fi
fi
if [[ "${opt_args[*]}" == *"-L"* ]]; then
    echo "The areas available to see EVR status are:"
    printf '%s\n' "${areas[@]}"
    printf "\n"
fi
if [[ "${opt_args[*]}" == *"-H" || "$i" == *"HELP" ]]; then
    echo " $( usage ) "
    printf "\n"
fi

if [[ "${opt_args[*]}" == *"--PVS"* && ${#area_args[@]} -ne 0 ]]; then

    for i in "${area_args[@]}"; do  
	hutch=${i^^}
	req_evrs_func
        printf "\n"
        echo "Here are the PVs currently loaded into the script for:" "$hutch"
        printf "\n"
        for j in "${req_evrs[@]}"; do echo "$j"; done
        printf "\n"
    done
    exit
fi

if [[ "${opt_args[*]}" == "--PVS" && ${#area_args[@]} -eq 0 ]]; then
     read_hutch
     in_areas
     printf "\n"
     req_evrs_func 
     echo "Here are the PVs currently loaded into the script for:" "$hutch"
     for j in "${req_evrs[@]}"; do echo "$j"; done
         printf "\n" 
fi
  
if [[ ${#area_args[@]} -ne 0 ]]; then
   for i in "${area_args[@]}"; do
       hutch=$i
       in_areas
       req_evrs_func
       to_display
   done
fi
if [[ ${#pv_args[@]} -ne 0 ]]; then
   to_display

elif [[ "${opt_args[*]}" == *"-EVR"* && ${#pv_args[@]} -eq 0 ]]; then
   manual_pv_entry
fi
if [[ ${#except_args[@]} -ne 0 && "${opt_args[*]}" != "--SHOW" ]]; then
    except_handling
fi
